{
    "atcoder": {
        "prefix": "atcoder",
        "body": [
            "#![allow(unused_imports, dead_code, non_snake_case)]",
            "",
            "// {{{ use",
            "use itertools::Itertools;",
            "use num::{",
            "    abs,",
            "    integer::{gcd, lcm, Roots},",
            "    pow, range_step, range_step_inclusive,",
            "};",
            "use petgraph::{",
            "    algo::{bellman_ford, dijkstra},",
            "    graph::{node_index, DiGraph, UnGraph},",
            "    unionfind::UnionFind,",
            "    visit::{depth_first_search, DfsEvent},",
            "};",
            "use proconio::{",
            "    input,",
            "    marker::{Bytes, Chars, Usize1},",
            "};",
            "use std::cmp::{max, min, Ordering, Reverse};",
            "use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};",
            "use std::mem::swap;",
            "use superslice::Ext;",
            "// }}}",
            "",
            "// {{{ const",
            "const MOD: usize = 1_000_000_007;",
            "const XY4: [(i64, i64); 4] = [(1, 0), (0, 1), (-1, 0), (0, -1)];",
            "const XY8: [(i64, i64); 8] = [",
            "    (1, 0),",
            "    (1, 1),",
            "    (0, 1),",
            "    (-1, 1),",
            "    (-1, 0),",
            "    (-1, -1),",
            "    (0, -1),",
            "    (1, -1),",
            "];",
            "// }}}",
            "",
            "// {{{ macro",
            "#[allow(unused_macros)]",
            "macro_rules! debug {",
            "    (\\$(\\$a:expr),* \\$(,)*) => {",
            "        #[cfg(debug_assertions)]",
            "        eprintln!(concat!(\\$(\"| \", stringify!(\\$a), \"={:?} \"),*, \"|\"), \\$(&\\$a),*);",
            "    };",
            "}",
            "",
            "#[allow(unused_macros)]",
            "macro_rules! chmin {",
            "    (\\$base:expr, \\$(\\$cmps:expr),+ \\$(,)*) => {{",
            "        let cmp_min = my_min!(\\$(\\$cmps),+);",
            "        if \\$base > cmp_min {",
            "            \\$base = cmp_min;",
            "            true",
            "        } else {",
            "            false",
            "        }",
            "    }};",
            "}",
            "",
            "#[allow(unused_macros)]",
            "macro_rules! chmax {",
            "    (\\$base:expr, \\$(\\$cmps:expr),+ \\$(,)*) => {{",
            "        let cmp_max = my_max!(\\$(\\$cmps),+);",
            "        if \\$base < cmp_max {",
            "            \\$base = cmp_max;",
            "            true",
            "        } else {",
            "            false",
            "        }",
            "    }};",
            "}",
            "",
            "#[allow(unused_macros)]",
            "macro_rules! my_min {",
            "    (\\$a:expr \\$(,)*) => {{",
            "        \\$a",
            "    }};",
            "    (\\$a:expr, \\$b:expr \\$(,)*) => {{",
            "        std::cmp::min(\\$a, \\$b)",
            "    }};",
            "    (\\$a:expr, \\$(\\$rest:expr),+ \\$(,)*) => {{",
            "        std::cmp::min(\\$a, my_min!(\\$(\\$rest),+))",
            "    }};",
            "}",
            "",
            "#[allow(unused_macros)]",
            "macro_rules! my_max {",
            "    (\\$a:expr \\$(,)*) => {{",
            "        \\$a",
            "    }};",
            "    (\\$a:expr, \\$b:expr \\$(,)*) => {{",
            "        std::cmp::max(\\$a, \\$b)",
            "    }};",
            "    (\\$a:expr, \\$(\\$rest:expr),+ \\$(,)*) => {{",
            "        std::cmp::max(\\$a, my_max!(\\$(\\$rest),+))",
            "    }};",
            "}",
            "// }}}",
            "",
            "fn main() {",
            "    input! {",
            "        $1",
            "    }",
            "    $2",
            "}"
        ],
        "description": ""
    },

    "debug": {
        "prefix": "debug",
        "body": [
            "#[allow(unused_macros)]",
            "macro_rules! debug {",
            "    (\\$(\\$a:expr),* \\$(,)*) => {",
            "        #[cfg(debug_assertions)]",
            "        eprintln!(concat!(\\$(\"| \", stringify!(\\$a), \"={:?} \"),*, \"|\"), \\$(&\\$a),*);",
            "    };",
            "}"
        ],
        "description": ""
    },

    "shotest_path": {
        "prefix": "shotest_path",
        "body": [
            "fn shotest_path(edges: &Vec<Vec<(usize, usize)>>, start: usize) -> Vec<usize> {",
            "    let mut dist = vec![1usize << 60; edges.len()];",
            "    let mut heap = BinaryHeap::new();",
            "",
            "    dist[start] = 0;",
            "    heap.push( (Reverse(0), start) );",
            "    while let Some( (Reverse(cost), pos) ) = heap.pop() {",
            "        if cost > dist[pos] { continue; }",
            "",
            "        for &(n_pos, n_cost) in &edges[pos] {",
            "            if cost + n_cost < dist[n_pos] {",
            "                dist[n_pos] = cost + n_cost;",
            "                heap.push( (Reverse(cost + n_cost), n_pos) );",
            "            }",
            "        }",
            "    }",
            "",
            "    dist",
            "}"
        ],
        "description": ""
    },

    "yesno": {
        "prefix": "yesno",
        "body": [
            "if ${1:cond} {",
            "    println!(\"Yes\");",
            "} else {",
            "    println!(\"No\");",
            "}"
        ],
        "description": ""
    },

    "printv": {
        "prefix": "printv",
        "body": [
            "println!(\"{}\", $1);$2"
        ],
        "description": ""
    }
}
